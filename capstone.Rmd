---
title: "Predicting Pitcher DL"
author: "Roger Chow"
date: "March 19, 2017"
output:
  pdf_document: default
  word_document: default
---

# Load libraries
```{r warning=FALSE}
setwd("F:/Capstone_Workspace/predictDL/");
library('RODBC');
library('DBI');
library('plyr');
library('dplyr');
library('stringi');
library('sqldf');
library('corrplot');
library('reshape2');
library('lattice');
library('ggplot2');
library('caret');
library('logistf');
library('klaR');
library('pROC');
library('pls');


resetPar <- function() {
    dev.new()
    op <- par(no.readonly = TRUE)
    dev.off()
    op
}

par(resetPar());
```

# Prepare data

## Load from Cache

Load the data from cache if the cache exists.  This is will save time when re-running the analysis since the data will not change.  It takes approximately 30 minutes to load the data from scratch.


```{r warning=FALSE}
need_load <- TRUE;
if (file.exists("pitches_dl_dataset.csv")){
  pitches_dl_dataset <- read.csv("pitches_dl_dataset.csv");
  pitches_dl_predict <- read.csv("pitches_dl_predict.csv");
  
  
  drops <- c("X");
  pitches_dl_dataset <- pitches_dl_dataset[ , !(names(pitches_dl_dataset) %in% drops)];
  pitches_dl_predict <- pitches_dl_predict[ , !(names(pitches_dl_predict) %in% drops)];

  need_load <- FALSE;
}

```


## Load pitchFX data from Database

If there is data cached, load the data from the SQL Server database.

Impute missing values using the Median.

The median is used to measure the central tendency for each continuous variable for each pitcher.  The count of the pitch types is also calculate for each pitcher in each year.  

```{r warning=FALSE}

if (need_load) {
  years <- c(2010, 2011, 2012, 2013, 2014, 2015, 2016);
  
  dbhandle <- odbcDriverConnect('driver={SQL Server};server=localhost;database=PitchFx;trusted_connection=true');
  
  impute <- function(x, fun) {
    missing <- is.na(x)
    replace(x, missing, fun(x[!missing]))
  }
  
    
  centroid_fun <- median;
  impute_fun <- median;
  
  
  for (i in 2010:2016)
  {
    query <-
   paste("SELECT	", i, " as season, m.rsID, p.id, p.atbatid, a.pitcher, 
            p.x, p.y, p.start_speed, p.end_speed, p.sz_top, p.sz_bot,
            p.px, p.pz, p.x0, p.y0, p.z0, p.vx0, p.vy0, p.vz0, p.ax, p.ay, p.az,
            p.break_y, p.break_length, p.spin_dir, p.spin_rate, 
            1 as type_ALL,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'AB' THEN 1 ELSE 0 END AS type_AB,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'AS' THEN 1 ELSE 0 END AS type_AS,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'CH' THEN 1 ELSE 0 END AS type_CH,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'CU' THEN 1 ELSE 0 END AS type_CU,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'EP' THEN 1 ELSE 0 END AS type_EP,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FA' THEN 1 ELSE 0 END AS type_FA,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FC' THEN 1 ELSE 0 END AS type_FC,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FF' THEN 1 ELSE 0 END AS type_FF,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FO' THEN 1 ELSE 0 END AS type_FO,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FS' THEN 1 ELSE 0 END AS type_FS,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FT' THEN 1 ELSE 0 END AS type_FT,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'IN' THEN 1 ELSE 0 END AS type_IN,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'KC' THEN 1 ELSE 0 END AS type_KC,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'KN' THEN 1 ELSE 0 END AS type_KN,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'PO' THEN 1 ELSE 0 END AS type_PO,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'SC' THEN 1 ELSE 0 END AS type_SC,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'SI' THEN 1 ELSE 0 END AS type_SI,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'SL' THEN 1 ELSE 0 END AS type_SL,
            CASE WHEN ISNULL(p.pitch_type,'UN') not in ('AS', 'CH', 'CU', 'EP', 'FA', 'FC', 'FF', 'FO', 'FS', 'FT', 'IN', 'KC', 'KN', 'PO', 'SC', 'SI') THEN 1 ELSE 0 END as type_UN
          FROM [PitchFx",i,"].[dbo].[Pitches] p
          INNER JOIN [PitchFx",i,"].[dbo].[AtBats] a on a.ID = p.AtBatID
          INNER JOIN [Mapping].[dbo].[RSID_MLBID_MAP] m on a.pitcher = m.mlbid
          INNER JOIN [Lahman].[dbo].[Master] ms on ms.retroID = m.rsID", sep="");
    
    pitches_raw <-sqlQuery(dbhandle, query);
  
    
    pitches_impute_centroid <- ddply(pitches_raw, ~rsID, transform,
                    x = impute(x, impute_fun),
                    y = impute(y, impute_fun),
                    start_speed = impute(start_speed, impute_fun),
                    end_speed = impute(end_speed, impute_fun),
                    sz_top = impute(sz_top, impute_fun),
                    sz_bot = impute(sz_bot, impute_fun),
                    px = impute(px, impute_fun),
                    pz = impute(pz, impute_fun),
                    x0 = impute(x0, impute_fun),
                    y0 = impute(y0, impute_fun),
                    z0 = impute(z0, impute_fun), 
                    vx0 = impute(vx0, impute_fun),
                    vy0 = impute(vy0, impute_fun),
                    vz0 = impute(vz0, impute_fun),
                    ax = impute(ax, impute_fun),
                    ay = impute(ay, impute_fun),
                    az = impute(az, impute_fun),
                    break_y = impute(break_y, impute_fun),
                    break_length = impute(break_length, impute_fun),
                    spin_dir = impute(spin_dir, impute_fun),
                    spin_rate =  impute(spin_rate, impute_fun)
                    );
  
   pitches_aggregate <- ddply(pitches_impute_centroid, ~rsID, summarise,
                    season = max(season),
                    x  = centroid_fun(x),
                    y = centroid_fun(y),
                    start_speed = centroid_fun(start_speed),
                    end_speed = centroid_fun(end_speed),
                    sz_top = centroid_fun(sz_top),
                    sz_bot = centroid_fun(sz_bot),
                    px = centroid_fun(px),
                    pz = centroid_fun(pz),
                    x0 = centroid_fun(x0),
                    y0 = centroid_fun(y0),
                    z0 = centroid_fun(z0), 
                    vx0 = centroid_fun(vx0),
                    vy0 = centroid_fun(vy0),
                    vz0 = centroid_fun(vz0),
                    ax = centroid_fun(ax),
                    ay = centroid_fun(ay),
                    az = centroid_fun(az),
                    break_y = centroid_fun(break_y),
                    break_length = centroid_fun(break_length),
                    spin_dir = centroid_fun(spin_dir),
                    spin_rate =  centroid_fun(spin_rate),
                    num_pitches = sum(type_ALL),
                    num_AB = sum(type_AB),
                    num_AS = sum(type_AS),
                    num_CH = sum(type_CH),
                    num_CU = sum(type_CU),
                    num_EP = sum(type_EP),
                    num_FA = sum(type_FA),
                    num_FC = sum(type_FC),
                    num_FF = sum(type_FF),
                    num_FO = sum(type_FO),
                    num_FS = sum(type_FS),
                    num_FT = sum(type_FT),
                    num_IN = sum(type_IN),
                    num_KC = sum(type_KC),
                    num_KN = sum(type_KN),
                    num_PO = sum(type_PO),
                    num_SC = sum(type_SC),
                    num_SI = sum(type_SI),
                    num_SL = sum(type_SL),
                    num_UN = sum(type_UN)
                    );
                 
    assign(paste("pitches",i,sep=""), pitches_aggregate);
    
  };
  
  pitches <- rbind(pitches2010, pitches2011, pitches2012, pitches2013, pitches2014, pitches2015, pitches2016);
  pitches <- pitches[complete.cases(pitches),];
  
  
  close(dbhandle);
}
```


## Load the disabled this

If there is no data cached, load the disable list data from the SQL Server database.

This data contains the list of pitchers on the disable list in each year.  Define a new column for season_1  to denote the previous season.  This is required since the pitching data from the previous season will be used to determine if the player will be on the disabled list in the current season. 

```{r warning=FALSE}
 if (need_load) {
  dbhandle <- odbcDriverConnect('driver={SQL Server};server=localhost;database=PitchFx;trusted_connection=true');
  query <- " 
  SELECT rsid, 2011 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2011]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2012 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2012]
    WHERE Pos in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2013 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2013]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2014 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2014]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2015 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2015]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2016 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2016]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  ";
  
  dl <- sqlQuery(dbhandle, query);
  dl <- dl[complete.cases(dl),];
  dl$season_1 <- dl$season-1;
  close(dbhandle);
 }
```


## Join the pitch and disabled list data

If there is no data cached, join the pitching data and disabled list data by season.  

Define the response variable OnDL to be TRUE if the pitcher is was on the disabled list or FALSE otherwise.

The pitching data from seasons 2010 to 2015 will be used to build and test the model since the disabled list is only available up to the 2016 season.

The pitching data from 2016 will be used to predict which players are most likey be on the disable list in 2017.

```{r warning=FALSE}
if (need_load) {
  #use previous season to predict DL in current season
  pitches_dl <- merge(x=pitches, y=dl, by.x=c("rsID", "season"), by.y=c("rsid", "season_1"), all.x = TRUE, all.y=FALSE)
  
  pitches_dl[pitches_dl==""] <- NA; #replace blanks with NA
  
  pitches_dl$DLDays[is.na(pitches_dl$DLDays)] <- 0; #no DL pitchers are on DL for 0 days
  pitches_dl$OnDL <- (ifelse(pitches_dl$DLDays>0, 1, 0));
  
  drops <- c("season_dl", "DLDays");
  pitches_dl <- pitches_dl[ , !(names(pitches_dl) %in% drops)];
  
  pitches_dl <- pitches_dl[complete.cases(pitches_dl),];
  
  pitches_dl_dataset <- pitches_dl[pitches_dl$season < 2016,]; #for modeling
  pitches_dl_predict <- pitches_dl[pitches_dl$season == 2016,]; #for 2017 prediction
  
  #pitches_dl_dataset$OnDL <- as.factor(ifelse(pitches_dl_dataset$DLDays>0, 'YES', 'NO'));
  
    
  drops <- c("season");
  pitches_dl_dataset <- pitches_dl_dataset[ , !(names(pitches_dl_dataset) %in% drops)];
  pitches_dl_predict <- pitches_dl_predict[ , !(names(pitches_dl_predict) %in% drops)];

  
  #write to csv to save time
  write.csv(pitches_dl_dataset, "pitches_dl_dataset.csv");
  write.csv(pitches_dl_dataset, "pitches_dl_predict.csv");
  
}
```

## Transform count variables

```{r warning=FALSE}
pitches_dl_dataset$trf_num_pitches <- sqrt(pitches_dl_dataset$num_pitches+(2/3));
pitches_dl_dataset$trf_num_AB <- sqrt(pitches_dl_dataset$num_AB+(2/3));
pitches_dl_dataset$trf_num_AS <- sqrt(pitches_dl_dataset$num_AS+(2/3));
pitches_dl_dataset$trf_num_CH <- sqrt(pitches_dl_dataset$num_CH+(2/3));
pitches_dl_dataset$trf_num_CU <- sqrt(pitches_dl_dataset$num_CU+(2/3));
pitches_dl_dataset$trf_num_EP <- sqrt(pitches_dl_dataset$num_EP+(2/3));
pitches_dl_dataset$trf_num_FA <- sqrt(pitches_dl_dataset$num_FA+(2/3));
pitches_dl_dataset$trf_num_FC <- sqrt(pitches_dl_dataset$num_FC+(2/3));
pitches_dl_dataset$trf_num_FF <- sqrt(pitches_dl_dataset$num_FF+(2/3));
pitches_dl_dataset$trf_num_FO <- sqrt(pitches_dl_dataset$num_FO+(2/3));
pitches_dl_dataset$trf_num_FS <- sqrt(pitches_dl_dataset$num_FS+(2/3));
pitches_dl_dataset$trf_num_FT <- sqrt(pitches_dl_dataset$num_FT+(2/3));
pitches_dl_dataset$trf_num_IN <- sqrt(pitches_dl_dataset$num_IN+(2/3));
pitches_dl_dataset$trf_num_KC <- sqrt(pitches_dl_dataset$num_KC+(2/3));
pitches_dl_dataset$trf_num_KN <- sqrt(pitches_dl_dataset$num_KN+(2/3));
pitches_dl_dataset$trf_num_PO <- sqrt(pitches_dl_dataset$num_PO+(2/3));
pitches_dl_dataset$trf_num_SC <- sqrt(pitches_dl_dataset$num_SC+(2/3));
pitches_dl_dataset$trf_num_SI <- sqrt(pitches_dl_dataset$num_SI+(2/3));
pitches_dl_dataset$trf_num_UN <- sqrt(pitches_dl_dataset$num_UN+(2/3));

pitches_dl_predict$trf_num_pitches <- sqrt(pitches_dl_predict$num_pitches+(2/3));
pitches_dl_predict$trf_num_AB <- sqrt(pitches_dl_predict$num_AB+(2/3));
pitches_dl_predict$trf_num_AS <- sqrt(pitches_dl_predict$num_AS+(2/3));
pitches_dl_predict$trf_num_CH <- sqrt(pitches_dl_predict$num_CH+(2/3));
pitches_dl_predict$trf_num_CU <- sqrt(pitches_dl_predict$num_CU+(2/3));
pitches_dl_predict$trf_num_EP <- sqrt(pitches_dl_predict$num_EP+(2/3));
pitches_dl_predict$trf_num_FA <- sqrt(pitches_dl_predict$num_FA+(2/3));
pitches_dl_predict$trf_num_FC <- sqrt(pitches_dl_predict$num_FC+(2/3));
pitches_dl_predict$trf_num_FF <- sqrt(pitches_dl_predict$num_FF+(2/3));
pitches_dl_predict$trf_num_FO <- sqrt(pitches_dl_predict$num_FO+(2/3));
pitches_dl_predict$trf_num_FS <- sqrt(pitches_dl_predict$num_FS+(2/3));
pitches_dl_predict$trf_num_FT <- sqrt(pitches_dl_predict$num_FT+(2/3));
pitches_dl_predict$trf_num_IN <- sqrt(pitches_dl_predict$num_IN+(2/3));
pitches_dl_predict$trf_num_KC <- sqrt(pitches_dl_predict$num_KC+(2/3));
pitches_dl_predict$trf_num_KN <- sqrt(pitches_dl_predict$num_KN+(2/3));
pitches_dl_predict$trf_num_PO <- sqrt(pitches_dl_predict$num_PO+(2/3));
pitches_dl_predict$trf_num_SC <- sqrt(pitches_dl_predict$num_SC+(2/3));
pitches_dl_predict$trf_num_SI <- sqrt(pitches_dl_predict$num_SI+(2/3));
pitches_dl_predict$trf_num_UN <- sqrt(pitches_dl_predict$num_UN+(2/3));

model_dataset <- pitches_dl_dataset[,-grep( "^num_" , names( pitches_dl_dataset ) )];
predict_dataset <- pitches_dl_predict[,-grep( "^num_" , names( pitches_dl_predict ) )];
                              
```

## Summary of data set

```{r warning=FALSE}

summary(model_dataset);

```

# Exploratory Analysis

## Histogram of data
```{r warning=FALSE}

d <- melt(model_dataset[sapply(model_dataset, is.numeric)]);

ggplot(d,aes(x = value)) + facet_wrap(~variable,scales = "free_x") +  geom_histogram();

```

## Check normality using QQ plot
```{r warning=FALSE}
par(mar=c(4,4,4,4))

for (i in 2:(ncol(model_dataset)-1)){  
  tmp <- model_dataset[, i];
  qqnorm(tmp, main = colnames(model_dataset[i]));
  qqline(tmp);
}
```


##Display correlation
```{r warning=FALSE}

numeric_dataset <- model_dataset[sapply(model_dataset, is.numeric)];

#ignore column y0 since there is 0 variance
numeric_dataset <- numeric_dataset[ , !(names(numeric_dataset) %in% c("y0", "OnDL"))];

#numeric_dataset <- numeric_dataset[1:(ncol(numeric_dataset))];
m <- cor(numeric_dataset);
corrplot::corrplot(m, type="upper");
```
# Model Building

## Create training and testing set using 70% training and 30% testing
```{r warning=FALSE}
train <- createDataPartition(model_dataset$OnDL, p=0.7, list=FALSE);


training <- model_dataset[train,];
  
# drops <- c("rsid");
# training <- training[ , !(names(training) %in% drops)];

testing <- model_dataset[-train,];
# testing <- testing[ , !(names(testing) %in% drops)];

dependent_var <- colnames(model_dataset[,-grep( "^OnDL" , names( model_dataset ) )])[-1];
original_var <- dependent_var[1:22];

response_var <- "OnDL";
```


## Model 1 All variables

### Construct Model
```{r warning=FALSE}
selected_variables <- dependent_var; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_1 = glm(formula = formula , family=binomial(logit), data=training);
```

### Summary
```{r warning=FALSE}
summary(mod_1);
```

### COefficients
```{r warning=FALSE}
mod_1$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_1, testing, type='response') > 0.6,  1, 0)
confusionMatrix(data=pred, reference=testing$OnDL);
```





## Model 2 Only low correlation variables

### Low correlation variables
```{r warning=FALSE}
highlyCorDescr <- findCorrelation(m, cutoff = .25)

lowCorColNames<- colnames(numeric_dataset[,-highlyCorDescr]);


#filter_pitches_dl_dataset <-  filteredDescr[,-highlyCorDescr]
#all_variables <- colnames(numeric_dataset);
print(lowCorColNames);

```

### Construct Model
```{r warning=FALSE}
selected_variables <- lowCorColNames; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_2 = glm(formula = formula , family=binomial(logit), data=training);

```

### Summary
```{r warning=FALSE}
summary(mod_2);
```

### Residual
```{r warning=TRUE}
plot(predict(mod_2),residuals(mod_2));
abline(h=0,lty=2,col="grey");
```

### COefficients
```{r warning=FALSE}
mod_2$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_2, testing, type='response') > 0.6,  1, 0);
confusionMatrix(data=pred, reference=testing$OnDL);
```


## Model 3 PCR

### Construct Model

https://pdfs.semanticscholar.org/6ef4/6cb18946dac5ad250f41df87f5c1c1745a1e.pdf
https://www.r-bloggers.com/performing-principal-components-regression-pcr-in-r/


```{r warning=FALSE}

training$OnDL <- (ifelse(training$OnDL == 1, 1, 0));

selected_variables <- lowCorColNames; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

pcr_model <- pcr(formula, data = training, scale =FALSE, validation = "CV");

```


### Summary
```{r warning=FALSE}
summary(pcr_model);
```

### Residual
```{r warning=TRUE}
par(mfrow = c(2, 2));
plot(pcr_model);

```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(pcr_model, testing, ncomp = 3) > 0.6,  1, 0);
confusionMatrix(data=pred, reference=testing$OnDL);
```

## Model 4 only original variables

### Construct Model
```{r warning=FALSE}
selected_variables <- original_var; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_4 = glm(formula = formula , family=binomial(logit), data=training);
```


### Summary
```{r warning=FALSE}
summary(mod_4);
```

### Residual
```{r warning=TRUE}
plot(predict(mod_4),residuals(mod_4));
abline(h=0,lty=2,col="grey");
```

### COefficients
```{r warning=FALSE}
mod_4$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_4, testing, type='response') > 0.6,  1, 0);
confusionMatrix(data=pred, reference=testing$OnDL);
```


## Model 5 PCR with original variables

### Construct Model

https://pdfs.semanticscholar.org/6ef4/6cb18946dac5ad250f41df87f5c1c1745a1e.pdf
https://www.r-bloggers.com/performing-principal-components-regression-pcr-in-r/


```{r warning=FALSE}

selected_variables <- original_var; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

pcr_model <- pcr(formula, data = training, scale =FALSE, validation = "CV");

```


### Summary
```{r warning=FALSE}
summary(pcr_model);
```

### Residual
```{r warning=TRUE}
par(mfrow = c(2, 2));
plot(pcr_model);

```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(pcr_model, testing, ncomp = 3) > 0.6,  1, 0);
confusionMatrix(data=pred, reference=testing$OnDL);
```
<!-- ```{r caret transformed model 1} -->
<!-- selected_variables <- lowCorColNames; # c('x', 'start_speed', 'y0', 'break_y', 'spin_dir', 'spin_rate', 'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->
<!-- ```{r coefficients of model 1} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->
<!-- ```{r evaluation of model 1} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->


<!-- ```{r filter highly pitch correlation 0.5} -->
<!-- highlyCorDescr <- findCorrelation(m, cutoff = .25) -->

<!-- lowCorColNames<- colnames(numeric_dataset[,-highlyCorDescr]); -->


<!-- #filter_pitches_dl_dataset <-  filteredDescr[,-highlyCorDescr] -->
<!-- #all_variables <- colnames(numeric_dataset); -->
<!-- print(lowCorColNames); -->

<!-- ``` -->


<!-- ```{r caret transformed model 2} -->
<!-- selected_variables <- lowCorColNames; # c('x', 'start_speed', 'y0', 'break_y', 'spin_dir', 'spin_rate', 'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset_transform) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset_transform)[ncol(pitches_dl_dataset_transform)], "~", -->
<!--                       paste(names(pitches_dl_dataset_transform)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->



<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->
<!-- ```{r evaluation of model 2} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->




<!-- ```{r caret model 2} -->
<!-- selected_variables <- c('x', 'start_speed', 'y0', 'break_y', 'spin_dir', 'spin_rate',  -->
<!--                         'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->

<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->

<!-- ```{r evaluation of model 2} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->
<!-- ```{r significant varables} -->

<!-- selected_variables <- c('start_speed', 'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->

<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->

<!-- ```{r evaluation of model 2} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- #residuals<-resid(mod_fit); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->





<!-- ```{r predictions for 2017 using model 2} -->
<!-- prediction <- predict(mod_fit, newdata=pitches_dl_predict, type='prob'); -->
<!-- prediction <- cbind(pitches_dl_predict, prediction); -->

<!-- prediction_df <- as.data.frame(prediction); -->
<!-- prediction_df <- prediction_df[order(prediction_df$YES, decreasing = TRUE),]; -->
<!-- head(prediction_df[c('nameFirst', 'nameLast', 'num_pitches', 'YES')]); -->
<!-- ``` -->









<!-- ```{r k kold} -->

<!-- train_control <- trainControl(method="cv", number=10, savePredictions=T); -->

<!-- model <- train(OnDL~., data=pitches_dl_dataset, trControl=train_control, method="glm"); -->

<!-- print(model); -->


<!-- fitpredt <- function(t) ifelse(fitpred > t , TRUE,FALSE); -->



<!-- ``` -->

<!-- ```{r test} -->
<!-- fitpred <- model$finalModel$fitted.values; -->
<!-- fitpredt <- function(t) ifelse(fitpred > t , TRUE,FALSE); -->

<!-- confusionMatrix(fitpredt(0.7),pitches_dl_dataset$onDL) -->

<!-- ``` -->

<!-- ```{r logisic regression with logistf } -->
<!-- selected_variables <- lowCorrelatedCols; #c('x', 'start_speed', 'y0', 'break_y', 'spin_dir','num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in% lowCorColNames); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_1 = logistf(formula = formula, data=training); -->
<!-- summary(mod_1); -->


<!-- ``` -->

<!-- ```{r nothing model} -->
<!-- formula_text <- paste(names(training)[ncol(training)], "~1"); -->
<!-- formula <- as.formula(formula_text); -->


<!-- mod_nothing = glm(formula = formula , family=binomial(logit), data=training); -->

<!-- summary(mod_nothing); -->
<!-- ``` -->

<!-- ```{r evaluation of glm model} -->
<!-- pred <- ifelse(predict(mod_nothing, testing, type='response') > 0.5, 'YES', 'NO') -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->


<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_nothing$finalModel); -->

<!-- ``` -->




<!-- ```{r PCA} -->
<!-- standardised <- as.data.frame(scale(pitches_dl_dataset[sapply(pitches_dl_dataset, is.numeric)])); -->
<!-- pitch.pca <- prcomp(standardised); -->
<!--  summary(pitch.pca); -->
<!-- ``` -->

<!-- ```{r pca plot} -->
<!-- screeplot(pitch.pca, type="lines") -->
<!-- ``` -->

<!-- ```{r PCA with pre-preprocess} -->



<!-- ``` -->








