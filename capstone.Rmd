---
title: "Predicting Pitcher DL"
author: "Roger Chow"
date: "March 19, 2017"
output:
  pdf_document: default
  word_document: default
---

# Load libraries
```{r warning=FALSE}
setwd("F:/Capstone_Workspace/predictDL/");
library('RODBC');
library('DBI');
library('plyr');
library('dplyr');
library('stringi');
library('sqldf');
library('corrplot');
library('reshape2');
library('lattice');
library('ggplot2');
library('caret');
library('logistf');
library('klaR');
library('pROC');
library('pls');


resetPar <- function() {
    dev.new()
    op <- par(no.readonly = TRUE)
    dev.off()
    op
}

par(resetPar());
```

# Prepare data

## Load from Cache

Load the data from cache if the cache exists.  This is will save time when re-running the analysis since the data will not change.  It takes approximately 30 minutes to load the data from scratch.


```{r warning=FALSE}
need_load <- TRUE;
if (file.exists("pitches_dl_dataset.csv")){
  pitches_dl_dataset <- read.csv("pitches_dl_dataset.csv");
  pitches_dl_predict <- read.csv("pitches_dl_predict.csv");
  
  
  drops <- c("X");
  pitches_dl_dataset <- pitches_dl_dataset[ , !(names(pitches_dl_dataset) %in% drops)];
  pitches_dl_predict <- pitches_dl_predict[ , !(names(pitches_dl_predict) %in% drops)];

  need_load <- FALSE;
}

```


## Load pitchFX data from Database

If there is data cached, load the data from the SQL Server database.

Impute missing values using the Median.

The median is used to measure the central tendency for each continuous variable for each pitcher.  The count of the pitch types is also calculate for each pitcher in each year.  

```{r warning=FALSE}

if (need_load) {
  years <- c(2010, 2011, 2012, 2013, 2014, 2015, 2016);
  
  dbhandle <- odbcDriverConnect('driver={SQL Server};server=localhost;database=PitchFx;trusted_connection=true');
  
  impute <- function(x, fun) {
    missing <- is.na(x)
    replace(x, missing, fun(x[!missing]))
  }
  
    
  centroid_fun <- median;
  impute_fun <- median;
  
  
  for (i in 2010:2016)
  {
    query <-
   paste("SELECT	", i, " as season, m.rsID, p.id, p.atbatid, a.pitcher, 
            p.x, p.y, p.start_speed, p.end_speed, p.sz_top, p.sz_bot,
            p.px, p.pz, p.x0, p.y0, p.z0, p.vx0, p.vy0, p.vz0, p.ax, p.ay, p.az,
            p.break_y, p.break_length, p.spin_dir, p.spin_rate, 
            1 as type_ALL,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'AB' THEN 1 ELSE 0 END AS type_AB,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'AS' THEN 1 ELSE 0 END AS type_AS,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'CH' THEN 1 ELSE 0 END AS type_CH,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'CU' THEN 1 ELSE 0 END AS type_CU,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'EP' THEN 1 ELSE 0 END AS type_EP,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FA' THEN 1 ELSE 0 END AS type_FA,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FC' THEN 1 ELSE 0 END AS type_FC,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FF' THEN 1 ELSE 0 END AS type_FF,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FO' THEN 1 ELSE 0 END AS type_FO,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FS' THEN 1 ELSE 0 END AS type_FS,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'FT' THEN 1 ELSE 0 END AS type_FT,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'IN' THEN 1 ELSE 0 END AS type_IN,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'KC' THEN 1 ELSE 0 END AS type_KC,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'KN' THEN 1 ELSE 0 END AS type_KN,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'PO' THEN 1 ELSE 0 END AS type_PO,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'SC' THEN 1 ELSE 0 END AS type_SC,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'SI' THEN 1 ELSE 0 END AS type_SI,
            CASE WHEN ISNULL(p.pitch_type,'UN') = 'SL' THEN 1 ELSE 0 END AS type_SL,
            CASE WHEN ISNULL(p.pitch_type,'UN') not in ('AS', 'CH', 'CU', 'EP', 'FA', 'FC', 'FF', 'FO', 'FS', 'FT', 'IN', 'KC', 'KN', 'PO', 'SC', 'SI') THEN 1 ELSE 0 END as type_UN
          FROM [PitchFx",i,"].[dbo].[Pitches] p
          INNER JOIN [PitchFx",i,"].[dbo].[AtBats] a on a.ID = p.AtBatID
          INNER JOIN [Mapping].[dbo].[RSID_MLBID_MAP] m on a.pitcher = m.mlbid
          INNER JOIN [Lahman].[dbo].[Master] ms on ms.retroID = m.rsID", sep="");
    
    pitches_raw <-sqlQuery(dbhandle, query);
  
    
    pitches_impute_centroid <- ddply(pitches_raw, ~rsID, transform,
                    x = impute(x, impute_fun),
                    y = impute(y, impute_fun),
                    start_speed = impute(start_speed, impute_fun),
                    end_speed = impute(end_speed, impute_fun),
                    sz_top = impute(sz_top, impute_fun),
                    sz_bot = impute(sz_bot, impute_fun),
                    px = impute(px, impute_fun),
                    pz = impute(pz, impute_fun),
                    x0 = impute(x0, impute_fun),
                    y0 = impute(y0, impute_fun),
                    z0 = impute(z0, impute_fun), 
                    vx0 = impute(vx0, impute_fun),
                    vy0 = impute(vy0, impute_fun),
                    vz0 = impute(vz0, impute_fun),
                    ax = impute(ax, impute_fun),
                    ay = impute(ay, impute_fun),
                    az = impute(az, impute_fun),
                    break_y = impute(break_y, impute_fun),
                    break_length = impute(break_length, impute_fun),
                    spin_dir = impute(spin_dir, impute_fun),
                    spin_rate =  impute(spin_rate, impute_fun)
                    );
  
   pitches_aggregate <- ddply(pitches_impute_centroid, ~rsID, summarise,
                    season = max(season),
                    x  = centroid_fun(x),
                    y = centroid_fun(y),
                    start_speed = centroid_fun(start_speed),
                    end_speed = centroid_fun(end_speed),
                    sz_top = centroid_fun(sz_top),
                    sz_bot = centroid_fun(sz_bot),
                    px = centroid_fun(px),
                    pz = centroid_fun(pz),
                    x0 = centroid_fun(x0),
                    y0 = centroid_fun(y0),
                    z0 = centroid_fun(z0), 
                    vx0 = centroid_fun(vx0),
                    vy0 = centroid_fun(vy0),
                    vz0 = centroid_fun(vz0),
                    ax = centroid_fun(ax),
                    ay = centroid_fun(ay),
                    az = centroid_fun(az),
                    break_y = centroid_fun(break_y),
                    break_length = centroid_fun(break_length),
                    spin_dir = centroid_fun(spin_dir),
                    spin_rate =  centroid_fun(spin_rate),
                    num_pitches = sum(type_ALL),
                    num_AB = sum(type_AB),
                    num_AS = sum(type_AS),
                    num_CH = sum(type_CH),
                    num_CU = sum(type_CU),
                    num_EP = sum(type_EP),
                    num_FA = sum(type_FA),
                    num_FC = sum(type_FC),
                    num_FF = sum(type_FF),
                    num_FO = sum(type_FO),
                    num_FS = sum(type_FS),
                    num_FT = sum(type_FT),
                    num_IN = sum(type_IN),
                    num_KC = sum(type_KC),
                    num_KN = sum(type_KN),
                    num_PO = sum(type_PO),
                    num_SC = sum(type_SC),
                    num_SI = sum(type_SI),
                    num_SL = sum(type_SL),
                    num_UN = sum(type_UN)
                    );
                 
    assign(paste("pitches",i,sep=""), pitches_aggregate);
    
  };
  
  pitches <- rbind(pitches2010, pitches2011, pitches2012, pitches2013, pitches2014, pitches2015, pitches2016);
  pitches <- pitches[complete.cases(pitches),];
  
  
  close(dbhandle);
}
```




## Load the disabled this

If there is no data cached, load the disable list data from the SQL Server database.

This data contains the list of pitchers on the disable list in each year.  Define a new column for season_1  to denote the previous season.  This is required since the pitching data from the previous season will be used to determine if the player will be on the disabled list in the current season. 

```{r warning=FALSE}
 if (need_load) {
  dbhandle <- odbcDriverConnect('driver={SQL Server};server=localhost;database=PitchFx;trusted_connection=true');
  query <- " 
  SELECT rsid, 2011 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2011]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2012 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2012]
    WHERE Pos in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2013 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2013]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2014 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2014]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2015 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2015]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  UNION
  SELECT rsid, 2016 as season_dl, sum(days) as DLDays
    FROM [DisabledList].[dbo].[DL2016]
    WHERE Position in ('LHP','RHP','RP','SP','P')
    GROUP BY rsid
  ";
  
  dl <- sqlQuery(dbhandle, query);
  dl <- dl[complete.cases(dl),];
  dl$season_1 <- dl$season-1;
  close(dbhandle);
 }
```


## Join the pitch and disabled list data

If there is no data cached, join the pitching data and disabled list data by season.  

Define the response variable OnDL to be TRUE if the pitcher is was on the disabled list or FALSE otherwise.

The pitching data from seasons 2010 to 2015 will be used to build and test the model since the disabled list is only available up to the 2016 season.

The pitching data from 2016 will be used to predict which players are most likey be on the disable list in 2017.

```{r warning=FALSE}
if (need_load) {
  #use previous season to predict DL in current season
  pitches_dl <- merge(x=pitches, y=dl, by.x=c("rsID", "season"), by.y=c("rsid", "season_1"), all.x = TRUE, all.y=FALSE)
  
  pitches_dl[pitches_dl==""] <- NA; #replace blanks with NA
  
  pitches_dl$DLDays[is.na(pitches_dl$DLDays)] <- 0; #no DL pitchers are on DL for 0 days
  pitches_dl$OnDL <- (ifelse(pitches_dl$DLDays>0, 1, 0));
  
  drops <- c("season_dl", "DLDays");
  pitches_dl <- pitches_dl[ , !(names(pitches_dl) %in% drops)];
  
  pitches_dl <- pitches_dl[complete.cases(pitches_dl),];
  
  pitches_dl_dataset <- pitches_dl[pitches_dl$season < 2016,]; #for modeling
  pitches_dl_predict <- pitches_dl[pitches_dl$season == 2016,]; #for 2017 prediction
  
  #pitches_dl_dataset$OnDL <- as.factor(ifelse(pitches_dl_dataset$DLDays>0, 'YES', 'NO'));
  
    
  drops <- c("season");
  pitches_dl_dataset <- pitches_dl_dataset[ , !(names(pitches_dl_dataset) %in% drops)];
  pitches_dl_predict <- pitches_dl_predict[ , !(names(pitches_dl_predict) %in% drops)];

  
  #write to csv to save time
  write.csv(pitches_dl_dataset, "pitches_dl_dataset.csv");
  write.csv(pitches_dl_dataset, "pitches_dl_predict.csv");
  
}
```

## Transform count variables
Apply Anscombe transformation to count variables

```{r warning=FALSE}
trf_func <- function(x) {
    return ( 2*sqrt(x+3/8));
}

pitches_dl_dataset$trf_num_pitches <- trf_func(pitches_dl_dataset$num_pitches);
pitches_dl_dataset$trf_num_AB <- trf_func(pitches_dl_dataset$num_AB);
pitches_dl_dataset$trf_num_AS <- trf_func(pitches_dl_dataset$num_AS);
pitches_dl_dataset$trf_num_CH <- trf_func(pitches_dl_dataset$num_CH);
pitches_dl_dataset$trf_num_CU <- trf_func(pitches_dl_dataset$num_CU);
pitches_dl_dataset$trf_num_EP <- trf_func(pitches_dl_dataset$num_EP);
pitches_dl_dataset$trf_num_FA <- trf_func(pitches_dl_dataset$num_FA);
pitches_dl_dataset$trf_num_FC <- trf_func(pitches_dl_dataset$num_FC);
pitches_dl_dataset$trf_num_FF <- trf_func(pitches_dl_dataset$num_FF);
pitches_dl_dataset$trf_num_FO <- trf_func(pitches_dl_dataset$num_FO);
pitches_dl_dataset$trf_num_FS <- trf_func(pitches_dl_dataset$num_FS);
pitches_dl_dataset$trf_num_FT <- trf_func(pitches_dl_dataset$num_FT);
pitches_dl_dataset$trf_num_IN <- trf_func(pitches_dl_dataset$num_IN);
pitches_dl_dataset$trf_num_KC <- trf_func(pitches_dl_dataset$num_KC);
pitches_dl_dataset$trf_num_KN <- trf_func(pitches_dl_dataset$num_KN);
pitches_dl_dataset$trf_num_PO <- trf_func(pitches_dl_dataset$num_PO);
pitches_dl_dataset$trf_num_SC <- trf_func(pitches_dl_dataset$num_SC);
pitches_dl_dataset$trf_num_SI <- trf_func(pitches_dl_dataset$num_SI);
pitches_dl_dataset$trf_num_SL <- trf_func(pitches_dl_dataset$num_SL);
pitches_dl_dataset$trf_num_UN <- trf_func(pitches_dl_dataset$num_UN);

pitches_dl_predict$trf_num_pitches <- trf_func(pitches_dl_predict$num_pitches);
pitches_dl_predict$trf_num_AB <- trf_func(pitches_dl_predict$num_AB);
pitches_dl_predict$trf_num_AS <- trf_func(pitches_dl_predict$num_AS);
pitches_dl_predict$trf_num_CH <- trf_func(pitches_dl_predict$num_CH);
pitches_dl_predict$trf_num_CU <- trf_func(pitches_dl_predict$num_CU);
pitches_dl_predict$trf_num_EP <- trf_func(pitches_dl_predict$num_EP);
pitches_dl_predict$trf_num_FA <- trf_func(pitches_dl_predict$num_FA);
pitches_dl_predict$trf_num_FC <- trf_func(pitches_dl_predict$num_FC);
pitches_dl_predict$trf_num_FF <- trf_func(pitches_dl_predict$num_FF);
pitches_dl_predict$trf_num_FO <- trf_func(pitches_dl_predict$num_FO);
pitches_dl_predict$trf_num_FS <- trf_func(pitches_dl_predict$num_FS);
pitches_dl_predict$trf_num_FT <- trf_func(pitches_dl_predict$num_FT);
pitches_dl_predict$trf_num_IN <- trf_func(pitches_dl_predict$num_IN);
pitches_dl_predict$trf_num_KC <- trf_func(pitches_dl_predict$num_KC);
pitches_dl_predict$trf_num_KN <- trf_func(pitches_dl_predict$num_KN);
pitches_dl_predict$trf_num_PO <- trf_func(pitches_dl_predict$num_PO);
pitches_dl_predict$trf_num_SC <- trf_func(pitches_dl_predict$num_SC);
pitches_dl_predict$trf_num_SI <- trf_func(pitches_dl_predict$num_SI);
pitches_dl_predict$trf_num_SL <- trf_func(pitches_dl_predict$num_SL);
pitches_dl_predict$trf_num_UN <- trf_func(pitches_dl_predict$num_UN);




model_dataset <- pitches_dl_dataset[,-grep( "^num_" , names( pitches_dl_dataset ) )];
predict_dataset <- pitches_dl_predict[,-grep( "^num_" , names( pitches_dl_predict ) )];
                              
```

# Exploratory Analysis

## Summary of data set

### List of variables
```{r warning=FALSE}
dependent_var <- colnames(model_dataset[,-grep( "^OnDL" , names( model_dataset ) )])[-1];
original_var <- dependent_var[1:21];
count_var <- dependent_var[22:40];
response_var <- "OnDL";
```

### Summary of continous variables
```{r warning=FALSE}
summary(model_dataset[which(colnames(model_dataset) %in% original_var)]);
```

### Summary of count variables after transforming
```{r warning=FALSE}
summary(model_dataset[which(colnames(model_dataset) %in% count_var)]);
```


## Histogram of data

### Continuous Variables
```{r warning=FALSE}
d <- melt(model_dataset[which(colnames(model_dataset) %in% original_var)]);
ggplot(d,aes(x = value)) + facet_wrap(~variable,scales = "free_x") +  geom_histogram();
```              
### Count Variables
```{r warning=FALSE}
d <- melt(model_dataset[which(colnames(model_dataset) %in% count_var)]);
ggplot(d,aes(x = value)) + facet_wrap(~variable,scales = "free_x") +  geom_histogram();
```  


## Outliers

(1) Fox, John. (1991). Regression Diagnostics: An Introduction. Sage Publications.

```{r warning=FALSE}
selected_variables <- dependent_var; 

selected_i <- which(colnames(model_dataset) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(model_dataset)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod <- glm(formula=formula, data=model_dataset);
cooksd <- cooks.distance(mod);

plot(cooksd, pch="*", cex=2, main="Influential Obs by Cooks distance");  # plot cook's distance
abline(h = 4*mean(cooksd, na.rm=T), col="red");  # add cutoff line
# text(x=1:length(cooksd)+1, y=cooksd, labels=ifelse(cooksd>10*mean(cooksd, na.rm=T),names(cooksd),""), col="red")
```

### Remove outliers
```{r warning=FALSE}
influential <- as.numeric(names(cooksd)[(cooksd > 4*mean(cooksd, na.rm=T))]);

model_dataset_lessOutliers <- model_dataset[-(influential[!is.na(influential)]), ];
```

### Summary of data after outliers removed
```{r warning=FALSE}
summary(model_dataset_lessOutliers);
```


## Check normality using QQ plot without outliers
```{r warning=FALSE}
par(mar=c(4,4,4,4))

for (i in 2:(ncol(model_dataset_lessOutliers)-1)){  
  tmp <- model_dataset_lessOutliers[, i];
  qqnorm(tmp, main = colnames(model_dataset_lessOutliers[i]));
  qqline(tmp);
}
```


##Display correlation

### All variables
```{r warning=FALSE}
numeric_dataset <- model_dataset[sapply(model_dataset, is.numeric)];

#ignore column y0 since there is 0 variance
numeric_dataset <- numeric_dataset[ , !(names(numeric_dataset) %in% c("y0", "OnDL"))];

#numeric_dataset <- numeric_dataset[1:(ncol(numeric_dataset))];
m <- cor(numeric_dataset);
corrplot::corrplot(m, type="upper");
```

### All variables without outliers
```{r warning=FALSE}
numeric_dataset_lessOutliers <- model_dataset_lessOutliers[sapply(model_dataset_lessOutliers, is.numeric)];

#ignore column y0 since there is 0 variance
numeric_dataset_lessOutliers <- numeric_dataset_lessOutliers[ , !(names(numeric_dataset_lessOutliers) %in% c("y0", "trf_num_AB", "OnDL"))];

#numeric_dataset <- numeric_dataset[1:(ncol(numeric_dataset))];
m_lessOutliers <- cor(numeric_dataset_lessOutliers);
corrplot::corrplot(m_lessOutliers, type="upper");
```



# Model Building with all data

## Create training and testing set using 75% training and 25% testing 
```{r warning=FALSE}
train <- createDataPartition(model_dataset$OnDL, p=0.75, list=FALSE);

training <- model_dataset[train,];

testing <- model_dataset[-train,];
```


## Model 1 All variables

### Construct Model
```{r warning=FALSE}
selected_variables <- dependent_var; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_1 = glm(formula = formula , family=binomial(logit), data=training);
```

### Summary

The summary shows that variables which have some significance to the outcomes are:
end_speed, sz_bot, pz, z0, vz0, break_y, break_length, trf_num_pitches, trf_num_CH, trf_num_FT, trf_num_SI, trf_num_UN
```{r warning=FALSE}
summary(mod_1);
```

### COefficients
```{r warning=FALSE}
mod_1$coefficients;
```

### Residual
```{r warning=TRUE}
plot(predict(mod_1),residuals(mod_1));
abline(h=0,lty=2,col="grey");
```

### Performance

This model produced 75.67% accuracy rate.
```{r warning=FALSE}
pred <- ifelse(predict(mod_1, testing, type='response') > 0.5,  1, 0)
confusionMatrix(data=pred, reference=testing$OnDL);
```

### ROC curve

```{r warning=FALSE}
prob <- predict(mod_1, testing, type='response');
g1 <- roc(OnDL ~ prob, data = testing);
plot(g1)  
```


# Model Building without outliers

## Create training and testing set using 75% training and 25% testing 
```{r warning=FALSE}
train_lessOutliers <- createDataPartition(model_dataset_lessOutliers$OnDL, p=0.75, list=FALSE);

training_lessOutliers <- model_dataset_lessOutliers[train_lessOutliers,];

testing_lessOutliers <- model_dataset_lessOutliers[-train_lessOutliers,];
```

## Model 1(b) All variables

### Construct Model
```{r warning=FALSE}
selected_variables <- dependent_var; 

selected_i <- which(colnames(training_lessOutliers) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training_lessOutliers)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_1b = glm(formula = formula , family=binomial(logit), data=training_lessOutliers);
```

### Summary

The summary shows that variables which have some significance to the outcomes are:
end_speed, break_length, trf_num_pitches, trf_num_FA, trf_num_FT, trf_num_KN
```{r warning=FALSE}
summary(mod_1b);
```


### COefficients
```{r warning=FALSE}
mod_1b$coefficients;
```

### Residual
```{r warning=TRUE}
plot(predict(mod_1b),residuals(mod_1b));
abline(h=0,lty=2,col="grey");
```

### Performance

With outliers removed, this model resulted in a 76.69% accuracy rate, slightly higher than the first model that considered all records for training.
```{r warning=FALSE}
pred <- ifelse(predict(mod_1b, testing_lessOutliers, type='response') > 0.5,  1, 0)
confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL);
```


### ROC curve

```{r warning=FALSE}
prob <- predict(mod_1b, testing_lessOutliers, type='response');
g1b <- roc(OnDL ~ prob, data = testing_lessOutliers);
plot(g1b)  
```

### Compare ROC of model with outliers vs model without outliers

The comparison of the ROC curve between the model with outliers (red) and one without outliers (blue) shows that the model has better performance once outliers are removed. 
```{r warning=FALSE}
plot(g1, col='red')  
plot(g1b, add=TRUE, col='blue')
```



## Model 2 Only low correlation variables (less than 0.5)

Using the data with outliers removed as the foundation, build a model with features that have a correlation of less than 0.5. 

### Low correlation variables
```{r warning=FALSE}
highlyCorDescr <- findCorrelation(m_lessOutliers, cutoff = .5)

lowCorColNames<- colnames(numeric_dataset[,-highlyCorDescr]);


#filter_pitches_dl_dataset <-  filteredDescr[,-highlyCorDescr]
#all_variables <- colnames(numeric_dataset);
print(lowCorColNames);

```

### Construct Model
```{r warning=FALSE}
selected_variables <- lowCorColNames; 

selected_i <- which(colnames(training_lessOutliers) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training_lessOutliers)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_2 = glm(formula = formula , family=binomial(logit), data=training_lessOutliers);

```

### Summary
```{r warning=FALSE}
summary(mod_2);
```

### Residual
```{r warning=TRUE}
plot(predict(mod_2),residuals(mod_2));
abline(h=0,lty=2,col="grey");
```

### COefficients
```{r warning=FALSE}
mod_2$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_2, testing, type='response') > 0.5,  1, 0);
confusionMatrix(data=pred, reference=testing$OnDL);
```
### ROC curve
```{r warning=FALSE}
prob <- predict(mod_2, testing, type='response');
g2 <- roc(OnDL ~ prob, data = testing);
plot(g2)  
```

## Model 2(b) Only low correlation variables (less than 0.75)

### Low correlation variables
```{r warning=FALSE}
highlyCorDescr <- findCorrelation(m_lessOutliers, cutoff = .75);

lowCorColNames <- colnames(numeric_dataset_lessOutliers[,-highlyCorDescr]);


#filter_pitches_dl_dataset <-  filteredDescr[,-highlyCorDescr]
#all_variables <- colnames(numeric_dataset);
print(lowCorColNames);

```

### Construct Model
```{r warning=FALSE}
selected_variables <- lowCorColNames; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training_lessOutliers)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_2b = glm(formula = formula , family=binomial(logit), data=training_lessOutliers);

```

### Summary
```{r warning=FALSE}
summary(mod_2b);
```

### Residual
```{r warning=TRUE}
plot(predict(mod_2b),residuals(mod_2b));
abline(h=0,lty=2,col="grey");
```

### COefficients
```{r warning=FALSE}
mod_2b$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_2b, testing_lessOutliers, type='response') > 0.5,  1, 0);
confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL);
```

### ROC curve
```{r warning=FALSE}
prob <- predict(mod_2b, testing_lessOutliers, type='response');
g2b <- roc(OnDL ~ prob, data = testing_lessOutliers);
plot(g2b)  
```





## Model 2(c) Only low correlation variables (less than 0.25)

### Low correlation variables
```{r warning=FALSE}
highlyCorDescr <- findCorrelation(m_lessOutliers, cutoff =0.25);

lowCorColNames <- colnames(numeric_dataset_lessOutliers[,-highlyCorDescr]);


#filter_pitches_dl_dataset <-  filteredDescr[,-highlyCorDescr]
#all_variables <- colnames(numeric_dataset);
print(lowCorColNames);

```

### Construct Model
```{r warning=FALSE}
selected_variables <- lowCorColNames; 

selected_i <- which(colnames(training) %in% selected_variables);
  
formula_text <- paste(response_var, "~",
                      paste(names(training_lessOutliers)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_2c = glm(formula = formula , family=binomial(logit), data=training_lessOutliers);

```

### Summary
```{r warning=FALSE}
summary(mod_2c);
```

### Residual
```{r warning=TRUE}
plot(predict(mod_2c),residuals(mod_2c));
abline(h=0,lty=2,col="grey");
```

### COefficients
```{r warning=FALSE}
mod_2c$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_2c, testing_lessOutliers, type='response') > 0.5,  1, 0);
confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL);
```

### ROC curve
```{r warning=FALSE}
prob <- predict(mod_2c, testing_lessOutliers, type='response');
g2c <- roc(OnDL ~ prob, data = testing_lessOutliers);
plot(g2c)  
```



## Compare ROC Curve of model by correlation

```{r warning=FALSE}
plot(g2, col='red'); #cutoff 0.5
plot(g2b, add=TRUE, col='blue') #cutoff 0.75
plot(g2c, add=TRUE, col='green')  #cutoff 0.25
```




## Model 3 Original continuous variables

### Construct Model
```{r warning=FALSE}
selected_variables <- original_var;

selected_i <- which(colnames(training_lessOutliers) %in% selected_variables);

formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_3 = glm(formula = formula , family=binomial(logit), data=training_lessOutliers);
```

### Summary
```{r warning=FALSE}
summary(mod_3);
```

### Residual
```{r warning=TRUE}
plot(predict(mod_3),residuals(mod_3));
abline(h=0,lty=2,col="grey");
```

### COefficients
```{r warning=FALSE}
mod_3$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_3, testing_lessOutliers, type='response') > 0.5,  1, 0);
confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL);
```

### ROC curve
```{r warning=FALSE}
prob <- predict(mod_3, testing_lessOutliers, type='response');
g3 <- roc(OnDL ~ prob, data = testing_lessOutliers);
plot(g3)
```



## Model 3(b) Siginifican Continue Variables + num pitches

### Construct Model
```{r warning=FALSE}
selected_variables <- c("y", "start_speed", "sz_bot", "pz", "vy0", "break_y", "trf_num_pitches");

selected_i <- which(colnames(training_lessOutliers) %in% selected_variables);

formula_text <- paste(response_var, "~",
                      paste(names(training)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

mod_3b = glm(formula = formula , family=binomial(logit), data=training_lessOutliers);
```

### Summary
```{r warning=FALSE}
summary(mod_3b);
```

### Residual
```{r warning=TRUE}
plot(predict(mod_3b),residuals(mod_3b));
abline(h=0,lty=2,col="grey");
```

### COefficients
```{r warning=FALSE}
mod_3b$coefficients;
```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(mod_3b, testing_lessOutliers, type='response') > 0.5,  1, 0);
confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL);
```

### ROC curve
```{r warning=FALSE}
prob <- predict(mod_3b, testing_lessOutliers, type='response');
g3b <- roc(OnDL ~ prob, data = testing_lessOutliers);
plot(g3b)
```

### Compare all models by ROC curve
```{r warning=FALSE}
plot(g1b, col='red');
plot(g2, col='blue', add=TRUE);
plot(g2b, col='green', add=TRUE);
plot(g2c, col='deeppink', add=TRUE);
plot(g3, col='skyblue', add=TRUE);
plot(g3b, col='limegreen', add=TRUE);

legend(0.2,0.4,       c("All Variable","Cutoff=0.5","Cutoff=0.75","Cutoff=0.25","Continuous Only","Continuous+Num Pitches"), lty=c(1,1), lwd=c(2.5,2.5),col=c("red","blue","green","deeppink","skyblue","limegreen"),pch=1, 
cex=0.75); # gives the legend lines the correct color and width
```



<!-- ## Model 4 only count variables -->

<!-- ### Construct Model -->
<!-- ```{r warning=FALSE} -->
<!-- selected_variables <- cbind(count_var);  -->

<!-- selected_i <- which(colnames(training_lessOutliers) %in% selected_variables); -->

<!-- formula_text <- paste(response_var, "~", -->
<!--                       paste(names(training_lessOutliers)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_4b = glm(formula = formula , family=binomial(logit), data=training_lessOutliers); -->
<!-- ``` -->

<!-- ### Summary -->
<!-- ```{r warning=FALSE} -->
<!-- summary(mod_4b); -->
<!-- ``` -->

<!-- ### Residual -->
<!-- ```{r warning=TRUE} -->
<!-- plot(predict(mod_4b),residuals(mod_4b)); -->
<!-- abline(h=0,lty=2,col="grey"); -->
<!-- ``` -->

<!-- ### COefficients -->
<!-- ```{r warning=FALSE} -->
<!-- mod_4b$coefficients; -->
<!-- ``` -->

<!-- ### Performance -->
<!-- ```{r warning=FALSE} -->
<!-- pred <- ifelse(predict(mod_4b, testing_lessOutliers, type='response') > 0.5,  1, 0); -->
<!-- confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL); -->
<!-- ``` -->

<!-- ### ROC curve -->
<!-- ```{r warning=FALSE} -->
<!-- prob <- predict(mod_4b, testing, type='response'); -->
<!-- g <- roc(OnDL ~ prob, data = testing); -->
<!-- plot(g)   -->
<!-- ``` -->



<!-- ## Model 5 continuous variables and num pitches -->

<!-- ### Construct Model -->
<!-- ```{r warning=FALSE} -->
<!-- selected_variables <- cbind(original_var, c("trf_num_pitches"));  -->

<!-- selected_i <- which(colnames(training) %in% selected_variables); -->

<!-- formula_text <- paste(response_var, "~", -->
<!--                       paste(names(training)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_6 = glm(formula = formula , family=binomial(logit), data=training); -->
<!-- ``` -->

<!-- ### Summary -->
<!-- ```{r warning=FALSE} -->
<!-- summary(mod_6); -->
<!-- ``` -->

<!-- ### Residual -->
<!-- ```{r warning=TRUE} -->
<!-- plot(predict(mod_6),residuals(mod_6)); -->
<!-- abline(h=0,lty=2,col="grey"); -->
<!-- ``` -->

<!-- ### COefficients -->
<!-- ```{r warning=FALSE} -->
<!-- mod_6$coefficients; -->
<!-- ``` -->

<!-- ### Performance -->
<!-- ```{r warning=FALSE} -->
<!-- pred <- ifelse(predict(mod_6, testing, type='response') > 0.6,  1, 0); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->

<!-- ### ROC curve -->
<!-- ```{r warning=FALSE} -->
<!-- prob <- predict(mod_6, testing, type='response'); -->
<!-- g <- roc(OnDL ~ prob, data = testing); -->
<!-- plot(g)   -->
<!-- ``` -->



<!-- ## Model 6(b) continuous variables and num pitches without outliers -->

<!-- ### Construct Model -->
<!-- ```{r warning=FALSE} -->
<!-- selected_variables <- cbind(original_var, c("trf_num_pitches"));  -->

<!-- selected_i <- which(colnames(training_lessOutliers) %in% selected_variables); -->

<!-- formula_text <- paste(response_var, "~", -->
<!--                       paste(names(training_lessOutliers)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_6b = glm(formula = formula , family=binomial(logit), data=training_lessOutliers); -->
<!-- ``` -->

<!-- ### Summary -->
<!-- ```{r warning=FALSE} -->
<!-- summary(mod_6b); -->
<!-- ``` -->

<!-- ### Residual -->
<!-- ```{r warning=TRUE} -->
<!-- plot(predict(mod_6b),residuals(mod_6b)); -->
<!-- abline(h=0,lty=2,col="grey"); -->
<!-- ``` -->

<!-- ### COefficients -->
<!-- ```{r warning=FALSE} -->
<!-- mod_6b$coefficients; -->
<!-- ``` -->

<!-- ### Performance -->
<!-- ```{r warning=FALSE} -->
<!-- pred <- ifelse(predict(mod_6b, testing_lessOutliers, type='response') > 0.6,  1, 0); -->
<!-- confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL); -->
<!-- ``` -->

<!-- ### ROC curve -->
<!-- ```{r warning=FALSE} -->
<!-- prob <- predict(mod_6b, testing_lessOutliers, type='response'); -->
<!-- g <- roc(OnDL ~ prob, data = testing_lessOutliers); -->
<!-- plot(g)   -->
<!-- ``` -->





## Model YYYY PCR with coninuous variables

### Construct Model

https://pdfs.semanticscholar.org/6ef4/6cb18946dac5ad250f41df87f5c1c1745a1e.pdf
https://www.r-bloggers.com/performing-principal-components-regression-pcr-in-r/


```{r warning=FALSE}

selected_variables <- dependent_var;

selected_i <- which(colnames(training_lessOutliers) %in% selected_variables);

formula_text <- paste(response_var, "~",
                      paste(names(training_lessOutliers)[selected_i], collapse="+"));
formula <- as.formula(formula_text);

pcr_model <- pcr(formula, data = training_lessOutliers, scale =FALSE, validation = "CV");

```


### Summary
```{r warning=FALSE}
summary(pcr_model);
```

### Residual
```{r warning=TRUE}
par(mfrow = c(2, 2));
plot(pcr_model);

```

### Performance
```{r warning=FALSE}
pred <- ifelse(predict(pcr_model, testing_lessOutliers, ncomp = 10) > 0.5,  1, 0);
confusionMatrix(data=pred, reference=testing_lessOutliers$OnDL);
```

### ROC curve
```{r warning=FALSE}
prob <- predict(pcr_model, testing_lessOutliers, type='response');
gPCR <- roc(OnDL ~ prob, data = testing_lessOutliers);
plot(gPCR)  
```



	
 
# Plot the root mean squared error
```{r warning=FALSE}

validationplot(pcr_model)
```

<!-- ```{r caret transformed model 1} -->
<!-- selected_variables <- lowCorColNames; # c('x', 'start_speed', 'y0', 'break_y', 'spin_dir', 'spin_rate', 'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->
<!-- ```{r coefficients of model 1} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->
<!-- ```{r evaluation of model 1} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->


<!-- ```{r filter highly pitch correlation 0.5} -->
<!-- highlyCorDescr <- findCorrelation(m, cutoff = .25) -->

<!-- lowCorColNames<- colnames(numeric_dataset[,-highlyCorDescr]); -->


<!-- #filter_pitches_dl_dataset <-  filteredDescr[,-highlyCorDescr] -->
<!-- #all_variables <- colnames(numeric_dataset); -->
<!-- print(lowCorColNames); -->

<!-- ``` -->


<!-- ```{r caret transformed model 2} -->
<!-- selected_variables <- lowCorColNames; # c('x', 'start_speed', 'y0', 'break_y', 'spin_dir', 'spin_rate', 'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset_transform) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset_transform)[ncol(pitches_dl_dataset_transform)], "~", -->
<!--                       paste(names(pitches_dl_dataset_transform)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->



<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->
<!-- ```{r evaluation of model 2} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->




<!-- ```{r caret model 2} -->
<!-- selected_variables <- c('x', 'start_speed', 'y0', 'break_y', 'spin_dir', 'spin_rate',  -->
<!--                         'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->

<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->

<!-- ```{r evaluation of model 2} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->
<!-- ```{r significant varables} -->

<!-- selected_variables <- c('start_speed', 'num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in%selected_variables); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_fit <- train(formula,  data=training, method="glm", family="binomial"); -->
<!-- summary(mod_fit); -->

<!-- ``` -->

<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_fit$finalModel); -->

<!-- ``` -->

<!-- ```{r evaluation of model 2} -->
<!-- pred <- predict(mod_fit, newdata=testing); -->
<!-- #residuals<-resid(mod_fit); -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->





<!-- ```{r predictions for 2017 using model 2} -->
<!-- prediction <- predict(mod_fit, newdata=pitches_dl_predict, type='prob'); -->
<!-- prediction <- cbind(pitches_dl_predict, prediction); -->

<!-- prediction_df <- as.data.frame(prediction); -->
<!-- prediction_df <- prediction_df[order(prediction_df$YES, decreasing = TRUE),]; -->
<!-- head(prediction_df[c('nameFirst', 'nameLast', 'num_pitches', 'YES')]); -->
<!-- ``` -->









<!-- ```{r k kold} -->

<!-- train_control <- trainControl(method="cv", number=10, savePredictions=T); -->

<!-- model <- train(OnDL~., data=pitches_dl_dataset, trControl=train_control, method="glm"); -->

<!-- print(model); -->


<!-- fitpredt <- function(t) ifelse(fitpred > t , TRUE,FALSE); -->



<!-- ``` -->

<!-- ```{r test} -->
<!-- fitpred <- model$finalModel$fitted.values; -->
<!-- fitpredt <- function(t) ifelse(fitpred > t , TRUE,FALSE); -->

<!-- confusionMatrix(fitpredt(0.7),pitches_dl_dataset$onDL) -->

<!-- ``` -->

<!-- ```{r logisic regression with logistf } -->
<!-- selected_variables <- lowCorrelatedCols; #c('x', 'start_speed', 'y0', 'break_y', 'spin_dir','num_pitches'); -->

<!-- selected_i <- which(colnames(pitches_dl_dataset) %in% lowCorColNames); -->

<!-- formula_text <- paste(names(pitches_dl_dataset)[ncol(pitches_dl_dataset)], "~", -->
<!--                       paste(names(pitches_dl_dataset)[selected_i], collapse="+")); -->
<!-- formula <- as.formula(formula_text); -->

<!-- mod_1 = logistf(formula = formula, data=training); -->
<!-- summary(mod_1); -->


<!-- ``` -->

<!-- ```{r nothing model} -->
<!-- formula_text <- paste(names(training)[ncol(training)], "~1"); -->
<!-- formula <- as.formula(formula_text); -->


<!-- mod_nothing = glm(formula = formula , family=binomial(logit), data=training); -->

<!-- summary(mod_nothing); -->
<!-- ``` -->

<!-- ```{r evaluation of glm model} -->
<!-- pred <- ifelse(predict(mod_nothing, testing, type='response') > 0.5, 'YES', 'NO') -->
<!-- confusionMatrix(data=pred, reference=testing$OnDL); -->
<!-- ``` -->


<!-- ```{r coefficients of model 2} -->

<!-- coef(mod_nothing$finalModel); -->

<!-- ``` -->




<!-- ```{r PCA} -->
<!-- standardised <- as.data.frame(scale(pitches_dl_dataset[sapply(pitches_dl_dataset, is.numeric)])); -->
<!-- pitch.pca <- prcomp(standardised); -->
<!--  summary(pitch.pca); -->
<!-- ``` -->

<!-- ```{r pca plot} -->
<!-- screeplot(pitch.pca, type="lines") -->
<!-- ``` -->

<!-- ```{r PCA with pre-preprocess} -->



<!-- ``` -->








